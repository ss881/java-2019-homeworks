# Java课程大作业——葫芦世界

## 一、代码结构

![](https://s2.ax1x.com/2019/12/20/QXa2xs.png)

## 二、设计思路

1. 分模块设计

![](https://s2.ax1x.com/2019/12/20/QXag2j.png)

将应用程序划分为三个模块：

*  用于界面布局和美化的`fxml`以及`css`代码；
* 用于转发用户请求的部分（又可以按照请求的种类划分为按钮点击事件以及键盘和鼠标事件）；
* 实现游戏功能的部分；

模块之间分离，仅保留必要的调用关系，划分责任之后各个模块可以分别进行开发，当一个模块的设计发生变更时不会影响其他模块的内容；

2. 设计原则的应用

* LSP原则

  游戏中出现的所有具体的生物类都继承自抽象的`Creature`类，因此在布阵的时候以及绘制场景的时候能够将所有的生物对象进行统一的处理；

* DIP原则

  所有依赖生物的地方都是依赖于抽象的`Creature`类，而不是具体的某个生物类；

* SRC原则

  每个类仅完成其语义范畴的功能，并不会承担超过其范围的职责；

* LOD原则

  所有方法和属性都遵循最低访问权限的要求，向外界尽可能暴露少的接口，方便外界使用同时也方便代码扩展；

* LSP原则

  为在布阵时能够呐喊助威的生物设计`Cheerable`接口，其他生物都不具有该功能；

3. 设计模式的引用

* 简单工厂

  * 生物工厂

  在设计的过程中，生物类的种类相对固定，但是在迭代开发过程中经常由于生物类新增了新的属性导致所有的生物类的构造方法都需要进行修改，通过引入一个简单工厂，将所有的生物对象的创建集中在工厂中，当生物结构发生变动的时候，只需要修改工厂中的方法即可；

  * 子弹工厂

  子弹属性较多，因此如果直接使用`new`创建会导致创建的地方代码很冗长，并且当子弹类的结构发生变动的时候也很不方便，而且子弹的很多属性都能够通过计算得到，但是如果在直接在构造方法中计算不太符合人的思维，通过引入一个简单工厂，用户只需要传入必要的数据，子弹的属性就能够计算出来并且创建好子弹对象，既符合使用者的思维又简化了创建子弹对象的过程并且方便今后进行更新；

  * 记录工厂

  在游戏进行的过程中，记录需要频繁的创建，并且创建的地方分散在代码的各处，如果记录的结构一旦发生变动，需要修改所有使用到记录的地方的代码，由于记录具有统一的格式，引入简单工厂之后，创建过程能过极大地简化，同时也方便进行记录的扩展；

* 构建者模式

  * `TeamBuilder`

  `Team`中组合了属于该团队的所有生物对象，虽然在前面实现了生物工厂简化了生物对象的创建，但是如果直接使用工厂还是不方便进行今后的扩展，通过提供一个构建者类进行团队内部生物的创建并且完成将生物组装成团队，能够精确控制对象的创建并且进一步提高了易用性，同时也方便今后的扩展；

  * `WorldBuilder`

  `HuluWorld`类是游戏的核心类，今后当游戏功能发生变动的时候此类一定会受到影响，为了减轻这种影响，将其中的功能尽可能分解到各个类中，当需求发生变动的时候，针对其中的某个类进行修改或者扩展而不用修改`HuluWorld`类中的内容，提供`WorldBuilder`类也是这个目的

* 代理模式

  * `BulletManager`

  * `RecordManager`
  * `PositionManager`

  由于游戏中同时存在多个线程在运行，因此需要进行并发控制，进行简单分析之后，程序中的临界资源有

  * 子弹容器
  * 记录容器
  * 位置
  * 生物

  对于这些数据对象的修改需要保证同时只有一个线程在进行，但是如果直接将这些数据对象暴露出来，在各个线程访问的时候再进行加锁会使得加锁解锁的代码分散在程序的各个部分，当并发控制出现错误的时候很难进行调试，而且用于并发控制的代码和完成游戏功能的代码混杂在一起，可读性也会变差，因此对这些临界资源进行简单的封装，通过增加一个代理类为这些临界资源增加一个访问层，在代理类的内部进行并发控制，使得代码的可读性提高并且易于进行控制；

* 观察者模式

  * `endBattle`方法

  在游戏进行过程中，当出现胜利的一方的时候，此时`ui`线程需要通知其他所有线程终止，具体体现在代码中，`huluworld`类中记录了当前运行中的所有非`ui`线程，当战斗结束时，在该类的`endBattle`方法中会通知这些线程对象停止运行；

## 三、应用机制

1. 异常处理

当游戏中出现胜利的一方的时候，在`ui`线程中会设置其他线程的中断状态，其他线程会收到`InterruptedException`，在处理`InterruptedException`的`catch`语句块中结束这些线程的执行；

2. 泛型

- 在阵法类的布阵方法中使用了泛型通配符，能够在保证类型安全的前提下接受所有由`Creature`及其子类组成的`List`容器；
- `Team`类带有泛型参数，其子类`GoodTeam`和`BadTeam`在定义的时候对父类的泛型参数进行了实例化，因此在记录胜利一方的时候可以直接使用带泛型参数的`Team`类进行接收；

3. 注解

`util`包下的`PropPath`注解类为一些类添加了其所需要的配置文件的路径，当配置文件的路径发生变动的时候只需要修改注解中的属性而不需要修改代码中的内容；

4. 反射

* 在布阵时，利用`instanceof`运算符判断一个`Creature`引用指向的对象是否是`Cheerable`接口的实现类，实现老爷爷和蛇精的呐喊助威功能；
* 在`Config`类以及`ImageLoader`这类需要读取配置文件的类中加了`PropPath`注解，通过反射机制能够读取注解的内容从而获取配置文件的路径，完成配置文件的加载；

5. 输入输出

游戏记录的保存和加载；

## 四、项目特点

1. 消息传递机制

代码分为三个模块，在请求处理模块，当接受到用户来自按钮，鼠标或者键盘事件，就会调用游戏功能模块的代码执行，在执行过程中游戏功能模块的数据会被更新，反馈回来界面会被刷新从而向用户呈现出响应的效果，体现了面向对象中消息传递的机制；

2. 并发控制方法

采用代理类的方式，对共享的数据对象提供一层访问层，其他线程想要访问这些数据对象的时候必须通过访问层的控制，因此能够保证在并发条件下数据不会出现错误；

3. 游戏暂停和继续

由于每个生物被实现为单独的一个线程，想要一个线程暂停运行可以通过设置标志位让线程进入死循环，但是这会造成线程的忙时等待，我的实现是在所有线程都要执行的一个程序点设置一把锁，当用户想要游戏暂停时只需要对该把锁进行加锁，其他线程就会因为加锁失败而进入阻塞状态，当用户想要继续游戏的时候再次释放锁这些线程又进入正常的执行状态；

4. 游戏记录

在游戏进行过程中，在一些关键节点处产生记录，将记录加到记录容器中，当用户要保存记录的时候，将这个容器中的所有记录写入文件即可，记录文件采用`json`格式，相比直接使用序列化的方式，用户能够采用普通的文本编辑器打开查看里面的内容，并且方便进行调试；在读取记录重放时只需要启动一个线程，读取记录的内容，按照每条记录插入的事件间隔放映记录即可；

## 五、功能介绍

1. 整体界面介绍

![](https://s2.ax1x.com/2019/12/20/QXa3VK.png)

2. 按钮功能

- 小喽啰布阵：蛇精一方变换阵型，可以用于在战斗开始之前调整蛇精一方的阵型；

- 葫芦娃排序/打乱葫芦娃：葫芦娃一方变换位置，可以用于在战斗开始之前调整葫芦娃一方的阵型；
- 关于葫芦世界：查看版本信息并且可以看到代码仓库的`url`，通过点击可以跳转到仓库地址；
- 开始战斗：葫芦娃和蛇精开始战斗，双方随机移动，发射子弹；
- 保存记录：保存上一场战斗的战斗记录到文件；
- 读取记录：读取文件中的记录并且重放；

3. 键盘和鼠标操作

- 鼠标点击选中生物（被选中的生物边框为金黄色），按WASD可以进行生物的移动，按K可以进行攻击（在战斗状态下）；
- 按下空格键，如果当前不处于战斗状态，则会进入战斗状态；如果当前已经处于战斗状态，则游戏会暂停，再次点击空格键会继续；
- 按下Q键会停止本轮游戏；

4. 游戏规则

游戏开始时所有生物有相同的攻击力（`INIT_DAMAGE`：默认为0.5），生命值（`INIT_HEALTH`：默认为`1.0`）以及击杀一个敌方生物之后增加的攻击力（`INCR_DAMAGE`：默认为`0.1`）（这些都可以通过配置文件`config.prop`进行配置），生物发出的子弹和当前生物具有相同的攻击力，当杀死一个敌方生物的时候自己会增加`INCR_DAMAGE`的攻击力，最终存活下来的一方生物胜利，会有胜利者的图片绘出；

## 六、运行截图

1. 游戏进行中

![](https://s2.ax1x.com/2019/12/20/QXaQDx.png)

2. 游戏结束时

![](https://s2.ax1x.com/2019/12/20/QXalb6.png)

## 八、UML类图

![](https://s2.ax1x.com/2019/12/20/QXahq0.png)

