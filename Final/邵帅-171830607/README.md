# 提交报告
***
ver1.0(作业3)
***
首先第一步要求存在一个二维空间
空间要创建位置，打算用一个二维数组来表示地图位置。而数组的类型就是生物体类。
刚开始想的是新建一个二维空间类，每个生物都有自己的位置成员，但是这种方法会在打印时产生麻烦，而且根据题中的描述，二维空间是提前存在的，我们要把生物放置于二维空间中，因此打算采用上帝视角的二维数组来完成。使用一个生物类的二维数组，本来还想构建阵法类来存储阵法，但发现实现起来会比较麻烦，故让上帝选择它喜欢的两种阵法。
在实现的过程中发现可以不用葫芦娃类直接使用生物类就够了，因为在实现中只要用到生物的名字。
一开始用flag变量想表示此生物是否真实存在，但后来在实际实现中发现可以省去。但可能会在以后的设计中使用到。因为在使用生物类数组时，数组元素很可能表示的不是生物而是一个空位。

***
重构ver2.0(作业4)
***
之前的实现觉得不太符合面向对象的程序设计思路，因此重新更改了架构。

UML图：
![](https://github.com/ss881/picture/blob/master/type1_uml.png)

首先是对地图类(Map)的实现，地图初定为20*20的二维正方形网格，每个网格内可以仅放置一个生物。一个二维数组能实现基本功能，它应该是空地的集合，但是需要建立生物和空地的联系。这里最终的设计思路是聚集，抽象出来的地图类可以作为生物类的属性之一。毕竟每个生物都可以有它的坐标位置。(只要实体存在)

生物类(Organism)表示所有基本生物
子类有Brothers和Monsters分别表示葫芦娃和妖精
其中Brothers类里面包含一个Color枚举类。

阵法类Embattle负责对生物们进行列队，在这个作业里也是主体main函数所在位置，也负责打印输出。

可以创建一个生物类的List集合用于维护。

泛型：泛型就是指广泛的、普通的类型。在java中是指把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型。

下面这个函数用到了泛型（用来判别一个生物是否是坏人还是好人）
```
public <T extends Organism> int godorbad(T x) {
        String s = x.getClass().getSimpleName();
        if (s.equals("Monsters"))
            return 1; // 是坏人
        else
            return 0;
    }
```
上面的函数也可以用其他非泛型的方法来实现，这里只是为了泛型而泛型。

反射：
JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。
下图所示代码就用到了反射

![](https://github.com/ss881/picture/blob/master/Organism_cheer.png?)

这个函数可以判断是老爷爷（好人）还是蛇精（坏人）从而说出不同助威的话。

***
Final
***

线程：
```
public synchronized void changepos(int x, int y) {
        pos.x = x;
        pos.y = y;
    }
```
在生物体类改变坐标的时候使用synchronized避免冲突

实现了简单的单元测试用例完成对Organism类的测试.

在最终作业的实现中未能完成javafx的图形化框架实现。未能完成精彩战斗的回放。

只是使用终端输出的方式，生物体死去时会在名字后面加上“x”表示死去。
开始时葫芦兄弟站成长蛇阵，妖精们站成雁行阵然后分别朝向对面进军。

设计理念：
抽象性：Organism抽象生物类，Brother用到了抽象的Color类.
继承性：Brother和Monster继承Organism.
多态性：上面提到的反射和泛型机制.