第一眼上手阅读启发：
第一环节： 随意站队： 就是 --> shuffle函数（） 排序就是 sort（） 从头到尾排序就是forEach（） + 一系列选择器 map..collect..flite..collect..goupby..等等 +  lambda 
第二环节： 再随意站队：就是再次调用 shuffle 函数（） 按照二分法 ：就是调用 Sort（） + binary方法 ， 从头到尾
还是 forEach + lambda
第三环节： 在交换位置的时候报告交换的动作 ： --> 这个行为可以嵌入到 sort（） 函数里面。
⚠️但是很无奈没有冒泡排序的API，所以就只好自己写一个 static 的函数了。 所以就不能调用sorted了

面向对象分析：
先把简单的话说完：说为面对对象，就是创建类，再 new 出对象 ，再对new出来的对象搞各种事情....

严肃分析：
因为1-7个葫芦娃本身就是各种不同对象，因为每个葫芦都有自己不同的属性，所以千万不能把每个葫芦娃都设置成一个类，应该提取所有葫芦娃的共性。
即是应该“葫芦”才是一个类，或者说是“葫芦精”才是是一个类，1-7娃就是是葫芦类的实例。所谓的对象，都是生出来的（new）。
这七个葫芦娃（对象）很显然都是从葫芦（类）里蹦出来的，所以这就很顺利成章：葫芦（类）生（new）葫芦娃（对象）
所以这个实验，创建了两个类，一个葫芦，一个是颜色类，因为实验要求要比较颜色，所以把颜色设计为enum类可以很好地进行比较。
简单来看，葫芦娃 和 妖精 都是棋盘上的棋子，但是我们不能光有棋子，所以需要棋盘。
同时这个实验为了后续的扩展（从一维线性棋盘 —> 到二维线性棋盘，我们理应有一个棋盘类，不然怎么会有大作业的葫芦娃大战妖精！！
但是这次实验就直接偷懒, 上一维数组多简单！不过按照Effective Java书籍上老爷子说的 列表要优于数组。
所以如果要创建棋盘的话，我们使用ArrayList<ArrayList<int>> 就可以了，
但是这次 实验，只是简单的冒泡和二分。本质上是在线性层面上实现的，多以还没必要用上二维 ArrayList 
但是我们下次用到二维的时候直接上ArrayList<ArrayList<int>> 做棋盘就行了。  
⚠️ ：更多面向对象的编程思想请欣赏源代码！


