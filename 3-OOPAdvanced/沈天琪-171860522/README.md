![UML图](https://raw.githubusercontent.com/Price1999a/java-2019-homeworks/master/3-OOPAdvanced/%E6%B2%88%E5%A4%A9%E7%90%AA-171860522/srcForMD/UMLhw3.png)

由这张图中我们可以清晰地看到我们代码的设计方式。

一共由9个类构成了作业3所需程序。

具体而言，我们首先有一个战场类，即**BattleField**类，
这是一个**16*16**的**int**数组,其中存放的实际上就是对象**id**，
这就要求所有id是唯一的，这就是为什么我设计了**Involved**类。

在本例中战场是唯一的，不是分割的，这就适合单例模式用于实例化战场，
在这里我简单运用了**static**的相关语法。
我将战场上所有可能出现的存在——空格、葫芦娃、蛇精、爷爷、小怪
、蝎精都视作为对象。除空格外，他们都继承于空格。
这样，所有这些基类、派生类都共享一个战场，
即这些类包含了一个**BattleField**对象。

在我看来，每一个生物都要移动。空格虽然不是动物动不了，
为了减少代码量，我将**walkto**方法放在了**Being**类中。

特别的，蝎精是小怪们的指挥官，熟读兵书了解阵型，他又有法力，
他就有能力带着小怪们瞬间改换阵型，这一方法就是**orderMonsters**方法，
这一法术直接作用于战场，端的是方便无比。
（实际上，
当前如此设计的原因在于要编写一个指挥**Monster**们寻路以部阵的算法目前有一些复杂，
当前来看似乎没有必要，所以现在他们的移动方式是跃迁：一起进入第四维度
——即在地图上擦除自身，再在合适的位置进入战场——即把自己的位置写回战场）

最终**Involved**类集中了所有参战者们，参战者们又共享一个战场。
这样**Involved**类包含了所有基类和派生类，另外，对于**Scorpion 
Elder Snack**这些类而言，这又有类似代理的样式：
**Involved**中的一些方法就是其中包含的类的方法的封装。
另外有对**Involved**的说明，不包含显式的**Huluwa**类与**Monster**类的原因在于：
这二者没有相较于**Being**独特的方法，暂时无需如此操作
（虽然很明显未来几乎必须要在此基础上扩充）

可以注意到，在这个设计中，**Involved**类当前没有很好的遵循**SRP**，有许多函数可以导致其内部数据发生变化，但考虑到当前**Involved**类可以被视为最上层接口，现在还是可以接受的，但假如未来要在其中加入更多的代码行为，由于没有**SRP**，代码显然是易出错的。

基本上，对于**Being**类中的**print**函数，他可以算作对修改封闭的，除非我们未来要彻底改变命令行式的输出模式，所以**OCP**可以被认为部分遵从了，但对于**cheer()**函数，或许我们应该定义一个新的接口，当前设计显然是不好的。

我认为程序实现了**LSP**，基本实现了**ISP**，除了**Being**为了继承而写的**walkTo()**函数。

在当前程序中我没有使用抽象类或接口，因而当前程序并不符合**DIP**。

根据coad法则，显然我的程序中有一部分是不合适的，例如**print()**函数。但继承关系并没有用错。

在程序中我几乎没有考虑到异常处理情形，原因在于目前我的程序还没有输入要求，一切行为都是可预测的。但在之后的拓展中，异常处理显然是必要的。
