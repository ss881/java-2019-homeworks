#作业三 171860031 张兰兰
---
##需求分析
- 实现一个NxN的二维空间（N>10)，任意一个坐标上可站立一个生物体。
+ 让初始乱序的葫芦娃们按照排行顺序排成长蛇形。
- 蝎子精可以带领若干小喽啰排成不同阵型，与葫芦娃们形成对峙局面
+ 老爷爷和蛇精放在合适的位置，为各自一方加油助威

---

## 假设和依赖
- 小妖精的数量是在开局时可变化的，一旦游戏开始就固定人数，因此变化阵型时人数不变，只有阵型长相会根据人数有变化
 
---
##设计分析
###总控制设计 Processor类的实现
主要设计理念是将Processor视作操纵整个游戏的主人，因此它会储存一个动态的二维数组来表示地图，主人不需要知道地图上面存储了什么，只要调用游戏开始和游戏结束的函数即可实现整个过程，因此Block类聚合于Processor类；同时提供SwapEmoration的接口给Processor类以便它直接调用，来改变阵型

----

###人物设计 Block类与Character类的关系
因为Processor类没有必要知道自己的地图上储存了哪些东西，所以具体的实现通过Block类来实现，每个Block类上如果有人物则是一个小的Character类，如果没有人物就是null，这样的设计体现出了人物的位置的具体移动。

-----

###阵型变换设计 SwapEmoration接口的实现

此处我将每个阵型都是做一个Emoation对象，因此每个阵型都有自己独特的在地板上进行排兵布阵的method，这样的method将小喽啰的位置都记录在自己的成员变量中，以便未来的SwapEmoration接口调用,因下次SwapEmoration接口中阵型变化即根据原本的阵型中小妖精和蝎子精的储存位置将对应的block上的人物设置为退场状态，再根据即将变换的阵型的对应位置将block上的人物进行调离

---
##实现效果
每次阵型变化都会先展示退场，再展示上场

---

##面向对象的设计理念
###SRP 单一职责原则
Processor类中的人物变化是通过Block类实现的，实现了功能分离
###OCP 开放封闭原则
Processor类中的阵法变化是通过SwapEormation接口实现的
###LSP LISKOV替换法则
从Character类继承的子类Calabash、Grandpa、Snake、Pips、Scorpion都可以替换Character类。
###ISP 接口隔离原则
没有出现一个类拥有其功能所不需要的方法。
###CARP 合成/聚合复用原则
总控制Processor类由二维的Block类和一些其他变量聚合而成。
地板Block类是由Character类合成起来的。


---